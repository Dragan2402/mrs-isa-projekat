import { openBlock, createElementBlock, normalizeClass, createElementVNode, Fragment, renderList, renderSlot, normalizeProps, mergeProps, toDisplayString, withModifiers, createCommentVNode, withDirectives, withKeys, vModelText } from 'vue';

const validators = {
  email: new RegExp(/^[a-z][a-z0-9_\.]{2,50}@[a-z0-9]{2,}(\.[a-z0-9]{2,4}){1,2}$/),
  url: new RegExp(/^(https?|ftp|rmtp|mms):\/\/(([A-Z0-9][A-Z0-9_-]*)(\.[A-Z0-9][A-Z0-9_-]*)+)(:(\d+))?\/?/i),
  text: new RegExp(/^[a-zA-Z]+$/)
};
var script = {
  name: "Vue3TagsInput",
  emits: ['update:modelValue', 'on-limit', 'on-tags-changed', 'on-remove', 'on-error', 'on-focus', 'on-blur'],
  props: {
    readOnly: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: String,
      default: ''
    },
    validate: {
      type: [String, Function, Object],
      default: ""
    },
    addTagOnKeys: {
      type: Array,
      default: function () {
        return [13, // Enter
        188, // Comma ','
        32 // Space
        ];
      }
    },
    placeholder: {
      type: String,
      default: ''
    },
    tags: {
      type: Array,
      default: () => []
    },
    limit: {
      type: Number,
      default: -1
    },
    allowDuplicates: {
      type: Boolean,
      default: false
    },
    addTagOnBlur: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      isInputActive: false,
      isError: false,
      newTag: '',
      innerTags: []
    };
  },

  computed: {
    isLimit() {
      let isLimit = this.limit > 0 && Number(this.limit) === this.innerTags.length;

      if (isLimit) {
        this.$emit('on-limit');
      }

      return isLimit;
    }

  },
  watch: {
    error() {
      this.isError = this.error;
    },

    modelValue: {
      immediate: true,

      handler(value) {
        console.log('value: ', value);
        this.newTag = value;
      }

    },
    tags: {
      deep: true,
      immediate: true,

      handler(tags) {
        this.innerTags = [...tags];
      }

    },

    newTag() {
      if (this.newTag.length > 50) {
        this.$refs.inputTag.className = 'v3ti-new-tag v3ti-new-tag--error';
        this.$refs.inputTag.style.textDecoration = "underline";
      }
    }

  },
  methods: {
    makeItNormal(event) {
      this.$emit('update:modelValue', event.target.value);
      this.$refs.inputTag.className = 'v3ti-new-tag';
      this.$refs.inputTag.style.textDecoration = "none";
    },

    resetData() {
      this.innerTags = [];
    },

    focusNewTag() {
      if (this.readOnly || !this.$el.querySelector(".v3ti-new-tag")) {
        return;
      }

      this.$el.querySelector(".v3ti-new-tag").focus();
    },

    handleInputFocus(event) {
      this.isInputActive = true;
      this.$emit('on-focus', event);
    },

    handleInputBlur(e) {
      this.isInputActive = false;
      this.addNew(e);
      this.$emit('on-blur', e);
    },

    addNew(e) {
      const keyShouldAddTag = e ? this.addTagOnKeys.indexOf(e.keyCode) !== -1 : true;
      const typeIsNotBlur = e && e.type !== "blur";

      if (!keyShouldAddTag && (typeIsNotBlur || !this.addTagOnBlur) || this.isLimit) {
        return;
      }

      if (this.newTag && (this.allowDuplicates || this.innerTags.indexOf(this.newTag) === -1) && this.validateIfNeeded(this.newTag) && this.newTag.length <= 50) {
        this.innerTags.push(this.newTag);
        this.newTag = "";
        this.$emit('update:modelValue', '');
        this.tagChange();
        e && e.preventDefault();
      } else {
        if (this.validateIfNeeded(this.newTag)) {
          if (this.newTag && this.newTag.length <= 50) {
            this.makeItError(true);
          } else {
            this.makeItError('maxLength');
          }
        } else {
          this.makeItError(false);
        }

        e && e.preventDefault();
      }
    },

    makeItError(isDuplicatedOrMaxLength) {
      this.$refs.inputTag.className = 'v3ti-new-tag v3ti-new-tag--error';
      this.$refs.inputTag.style.textDecoration = "underline";
      this.$emit('on-error', isDuplicatedOrMaxLength);
    },

    validateIfNeeded(tagValue) {
      if (this.validate === "" || this.validate === undefined) {
        return true;
      }

      if (typeof this.validate === "function") {
        return this.validate(tagValue);
      }

      if (typeof this.validate === "string" && Object.keys(validators).indexOf(this.validate) > -1) {
        return validators[this.validate].test(tagValue);
      }

      if (typeof this.validate === "object" && this.validate.test !== undefined) {
        return this.validate.test(tagValue);
      }

      return true;
    },

    removeLastTag() {
      if (this.newTag) {
        return;
      }

      this.innerTags.pop();
      this.tagChange();
    },

    remove(index) {
      this.innerTags.splice(index, 1);
      this.tagChange();
      this.$emit("on-remove", index);
    },

    tagChange() {
      this.$emit("on-tags-changed", this.innerTags);
    }

  }
};

const _hoisted_1 = {
  class: "v3ti-content"
};
const _hoisted_2 = {
  key: 1
};
const _hoisted_3 = ["onClick"];
const _hoisted_4 = ["placeholder"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    onClick: _cache[6] || (_cache[6] = $event => $options.focusNewTag()),
    class: normalizeClass([{
      'v3ti--focus': $data.isInputActive,
      'v3ti--error': $data.isError
    }, "v3ti"])
  }, [createElementVNode("div", _hoisted_1, [(openBlock(true), createElementBlock(Fragment, null, renderList($data.innerTags, (tag, index) => {
    return openBlock(), createElementBlock("span", {
      key: index,
      class: "v3ti-tag"
    }, [_ctx.$slots.item ? renderSlot(_ctx.$slots, "item", normalizeProps(mergeProps({
      key: 0
    }, {
      name: tag,
      index
    }))) : (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(tag), 1)), !$props.readOnly ? (openBlock(), createElementBlock("a", {
      key: 2,
      onClick: withModifiers($event => $options.remove(index), ["prevent", "stop"]),
      class: "v3ti-remove-tag"
    }, null, 8, _hoisted_3)) : createCommentVNode("", true)]);
  }), 128)), withDirectives(createElementVNode("input", {
    ref: "inputTag",
    placeholder: $props.placeholder,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => $data.newTag = $event),
    onKeydown: [_cache[1] || (_cache[1] = withKeys(withModifiers(function () {
      return $options.removeLastTag && $options.removeLastTag(...arguments);
    }, ["stop"]), ["delete"])), _cache[2] || (_cache[2] = function () {
      return $options.addNew && $options.addNew(...arguments);
    })],
    onBlur: _cache[3] || (_cache[3] = function () {
      return $options.handleInputBlur && $options.handleInputBlur(...arguments);
    }),
    onFocus: _cache[4] || (_cache[4] = function () {
      return $options.handleInputFocus && $options.handleInputFocus(...arguments);
    }),
    onInput: _cache[5] || (_cache[5] = function () {
      return $options.makeItNormal && $options.makeItNormal(...arguments);
    }),
    class: "v3ti-new-tag"
  }, null, 40, _hoisted_4), [[vModelText, $data.newTag]])])], 2);
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".v3ti {\n  border-radius: 5px;\n  min-height: 32px;\n  line-height: 1.4 !important;\n  background-color: #fff;\n  border: 1px solid #9ca3af;\n  overflow: hidden;\n  cursor: text;\n  text-align: left;\n  -webkit-appearance: textfield;\n  display: flex;\n  flex-wrap: wrap;\n}\n.v3ti--focus {\n  outline: 0;\n  border-color: #000000;\n  box-shadow: 0 0 0 1px #000000;\n}\n.v3ti--error {\n  border-color: #F56C6C;\n}\n.v3ti .v3ti-content {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n}\n.v3ti .v3ti-tag {\n  display: flex;\n  font-weight: 400;\n  margin: 3px;\n  padding: 0 5px;\n  background: #317CAF;\n  color: #ffffff;\n  height: 27px;\n  border-radius: 5px;\n  align-items: center;\n}\n.v3ti .v3ti-tag .v3ti-remove-tag {\n  color: #ffffff;\n  transition: opacity 0.3s ease;\n  opacity: 0.5;\n  cursor: pointer;\n  padding: 0 5px 0 7px;\n}\n.v3ti .v3ti-tag .v3ti-remove-tag::before {\n  content: \"x\";\n}\n.v3ti .v3ti-tag .v3ti-remove-tag:hover {\n  opacity: 1;\n}\n.v3ti .v3ti-new-tag {\n  background: transparent;\n  border: 0;\n  font-weight: 400;\n  margin: 3px;\n  outline: none;\n  padding: 0 4px;\n  flex: 1;\n  min-width: 60px;\n  height: 27px;\n}\n.v3ti .v3ti-new-tag--error {\n  color: #F56C6C;\n}";
styleInject(css_248z);

script.render = render;

// Import vue component
// IIFE injects install function into component, allowing component
// to be registered via Vue.use() as well as Vue.component(),

var entry_esm = /*#__PURE__*/(() => {
  // Get component instance
  const installable = script; // Attach install function executed by Vue.use()

  installable.install = app => {
    app.component('Vue3TagsInput', installable);
  };

  return installable;
})(); // It's possible to expose named exports when writing components that can
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = directive;

export { entry_esm as default };
