'use strict';var vue=require('vue');function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}var validators = {
  email: new RegExp(/^[a-z][a-z0-9_\.]{2,50}@[a-z0-9]{2,}(\.[a-z0-9]{2,4}){1,2}$/),
  url: new RegExp(/^(https?|ftp|rmtp|mms):\/\/(([A-Z0-9][A-Z0-9_-]*)(\.[A-Z0-9][A-Z0-9_-]*)+)(:(\d+))?\/?/i),
  text: new RegExp(/^[a-zA-Z]+$/)
};
var script = {
  name: "Vue3TagsInput",
  emits: ['update:modelValue', 'on-limit', 'on-tags-changed', 'on-remove', 'on-error', 'on-focus', 'on-blur'],
  props: {
    readOnly: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: String,
      default: ''
    },
    validate: {
      type: [String, Function, Object],
      default: ""
    },
    addTagOnKeys: {
      type: Array,
      default: function _default() {
        return [13, // Enter
        188, // Comma ','
        32 // Space
        ];
      }
    },
    placeholder: {
      type: String,
      default: ''
    },
    tags: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    limit: {
      type: Number,
      default: -1
    },
    allowDuplicates: {
      type: Boolean,
      default: false
    },
    addTagOnBlur: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isInputActive: false,
      isError: false,
      newTag: '',
      innerTags: []
    };
  },
  computed: {
    isLimit: function isLimit() {
      var isLimit = this.limit > 0 && Number(this.limit) === this.innerTags.length;

      if (isLimit) {
        this.$emit('on-limit');
      }

      return isLimit;
    }
  },
  watch: {
    error: function error() {
      this.isError = this.error;
    },
    modelValue: {
      immediate: true,
      handler: function handler(value) {
        console.log('value: ', value);
        this.newTag = value;
      }
    },
    tags: {
      deep: true,
      immediate: true,
      handler: function handler(tags) {
        this.innerTags = _toConsumableArray(tags);
      }
    },
    newTag: function newTag() {
      if (this.newTag.length > 50) {
        this.$refs.inputTag.className = 'v3ti-new-tag v3ti-new-tag--error';
        this.$refs.inputTag.style.textDecoration = "underline";
      }
    }
  },
  methods: {
    makeItNormal: function makeItNormal(event) {
      this.$emit('update:modelValue', event.target.value);
      this.$refs.inputTag.className = 'v3ti-new-tag';
      this.$refs.inputTag.style.textDecoration = "none";
    },
    resetData: function resetData() {
      this.innerTags = [];
    },
    focusNewTag: function focusNewTag() {
      if (this.readOnly || !this.$el.querySelector(".v3ti-new-tag")) {
        return;
      }

      this.$el.querySelector(".v3ti-new-tag").focus();
    },
    handleInputFocus: function handleInputFocus(event) {
      this.isInputActive = true;
      this.$emit('on-focus', event);
    },
    handleInputBlur: function handleInputBlur(e) {
      this.isInputActive = false;
      this.addNew(e);
      this.$emit('on-blur', e);
    },
    addNew: function addNew(e) {
      var keyShouldAddTag = e ? this.addTagOnKeys.indexOf(e.keyCode) !== -1 : true;
      var typeIsNotBlur = e && e.type !== "blur";

      if (!keyShouldAddTag && (typeIsNotBlur || !this.addTagOnBlur) || this.isLimit) {
        return;
      }

      if (this.newTag && (this.allowDuplicates || this.innerTags.indexOf(this.newTag) === -1) && this.validateIfNeeded(this.newTag) && this.newTag.length <= 50) {
        this.innerTags.push(this.newTag);
        this.newTag = "";
        this.$emit('update:modelValue', '');
        this.tagChange();
        e && e.preventDefault();
      } else {
        if (this.validateIfNeeded(this.newTag)) {
          if (this.newTag && this.newTag.length <= 50) {
            this.makeItError(true);
          } else {
            this.makeItError('maxLength');
          }
        } else {
          this.makeItError(false);
        }

        e && e.preventDefault();
      }
    },
    makeItError: function makeItError(isDuplicatedOrMaxLength) {
      this.$refs.inputTag.className = 'v3ti-new-tag v3ti-new-tag--error';
      this.$refs.inputTag.style.textDecoration = "underline";
      this.$emit('on-error', isDuplicatedOrMaxLength);
    },
    validateIfNeeded: function validateIfNeeded(tagValue) {
      if (this.validate === "" || this.validate === undefined) {
        return true;
      }

      if (typeof this.validate === "function") {
        return this.validate(tagValue);
      }

      if (typeof this.validate === "string" && Object.keys(validators).indexOf(this.validate) > -1) {
        return validators[this.validate].test(tagValue);
      }

      if (_typeof(this.validate) === "object" && this.validate.test !== undefined) {
        return this.validate.test(tagValue);
      }

      return true;
    },
    removeLastTag: function removeLastTag() {
      if (this.newTag) {
        return;
      }

      this.innerTags.pop();
      this.tagChange();
    },
    remove: function remove(index) {
      this.innerTags.splice(index, 1);
      this.tagChange();
      this.$emit("on-remove", index);
    },
    tagChange: function tagChange() {
      this.$emit("on-tags-changed", this.innerTags);
    }
  }
};var _hoisted_1 = {
  class: "v3ti-content"
};
var _hoisted_2 = {
  key: 1
};
var _hoisted_3 = ["onClick"];
var _hoisted_4 = ["placeholder"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", {
    onClick: _cache[6] || (_cache[6] = function ($event) {
      return $options.focusNewTag();
    }),
    class: vue.normalizeClass([{
      'v3ti--focus': $data.isInputActive,
      'v3ti--error': $data.isError
    }, "v3ti"])
  }, [vue.createElementVNode("div", _hoisted_1, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($data.innerTags, function (tag, index) {
    return vue.openBlock(), vue.createElementBlock("span", {
      key: index,
      class: "v3ti-tag"
    }, [_ctx.$slots.item ? vue.renderSlot(_ctx.$slots, "item", vue.normalizeProps(vue.mergeProps({
      key: 0
    }, {
      name: tag,
      index: index
    }))) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_2, vue.toDisplayString(tag), 1)), !$props.readOnly ? (vue.openBlock(), vue.createElementBlock("a", {
      key: 2,
      onClick: vue.withModifiers(function ($event) {
        return $options.remove(index);
      }, ["prevent", "stop"]),
      class: "v3ti-remove-tag"
    }, null, 8, _hoisted_3)) : vue.createCommentVNode("", true)]);
  }), 128)), vue.withDirectives(vue.createElementVNode("input", {
    ref: "inputTag",
    placeholder: $props.placeholder,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return $data.newTag = $event;
    }),
    onKeydown: [_cache[1] || (_cache[1] = vue.withKeys(vue.withModifiers(function () {
      return $options.removeLastTag && $options.removeLastTag.apply($options, arguments);
    }, ["stop"]), ["delete"])), _cache[2] || (_cache[2] = function () {
      return $options.addNew && $options.addNew.apply($options, arguments);
    })],
    onBlur: _cache[3] || (_cache[3] = function () {
      return $options.handleInputBlur && $options.handleInputBlur.apply($options, arguments);
    }),
    onFocus: _cache[4] || (_cache[4] = function () {
      return $options.handleInputFocus && $options.handleInputFocus.apply($options, arguments);
    }),
    onInput: _cache[5] || (_cache[5] = function () {
      return $options.makeItNormal && $options.makeItNormal.apply($options, arguments);
    }),
    class: "v3ti-new-tag"
  }, null, 40, _hoisted_4), [[vue.vModelText, $data.newTag]])])], 2);
}function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}var css_248z = ".v3ti {\n  border-radius: 5px;\n  min-height: 32px;\n  line-height: 1.4 !important;\n  background-color: #fff;\n  border: 1px solid #9ca3af;\n  overflow: hidden;\n  cursor: text;\n  text-align: left;\n  -webkit-appearance: textfield;\n  display: flex;\n  flex-wrap: wrap;\n}\n.v3ti--focus {\n  outline: 0;\n  border-color: #000000;\n  box-shadow: 0 0 0 1px #000000;\n}\n.v3ti--error {\n  border-color: #F56C6C;\n}\n.v3ti .v3ti-content {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n}\n.v3ti .v3ti-tag {\n  display: flex;\n  font-weight: 400;\n  margin: 3px;\n  padding: 0 5px;\n  background: #317CAF;\n  color: #ffffff;\n  height: 27px;\n  border-radius: 5px;\n  align-items: center;\n}\n.v3ti .v3ti-tag .v3ti-remove-tag {\n  color: #ffffff;\n  transition: opacity 0.3s ease;\n  opacity: 0.5;\n  cursor: pointer;\n  padding: 0 5px 0 7px;\n}\n.v3ti .v3ti-tag .v3ti-remove-tag::before {\n  content: \"x\";\n}\n.v3ti .v3ti-tag .v3ti-remove-tag:hover {\n  opacity: 1;\n}\n.v3ti .v3ti-new-tag {\n  background: transparent;\n  border: 0;\n  font-weight: 400;\n  margin: 3px;\n  outline: none;\n  padding: 0 4px;\n  flex: 1;\n  min-width: 60px;\n  height: 27px;\n}\n.v3ti .v3ti-new-tag--error {\n  color: #F56C6C;\n}";
styleInject(css_248z);script.render = render;// Import vue component
// IIFE injects install function into component, allowing component
// to be registered via Vue.use() as well as Vue.component(),

var component = /*#__PURE__*/(function () {
  // Get component instance
  var installable = script; // Attach install function executed by Vue.use()

  installable.install = function (app) {
    app.component('Vue3TagsInput', installable);
  };

  return installable;
})(); // It's possible to expose named exports when writing components that can
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = directive;
var namedExports=/*#__PURE__*/Object.freeze({__proto__:null,'default':component});// only expose one global var, with named exports exposed as properties of
// that global var (eg. plugin.namedExport)

Object.entries(namedExports).forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      exportName = _ref2[0],
      exported = _ref2[1];

  if (exportName !== 'default') component[exportName] = exported;
});module.exports=component;